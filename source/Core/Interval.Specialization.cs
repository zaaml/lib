
// <copyright file="Interval.cs" author="Dmitry Kravchenin" email="d.kravchenin@zaaml.com">
//   Copyright (c) Zaaml. All rights reserved.
// </copyright>

// *************************************************************
//
// AutoGenerated
//
// *************************************************************

// ReSharper disable All

using System;
using System.Collections.Generic;
using Zaaml.Core.Extensions;


namespace Zaaml.Core
{
	internal struct IntervalMinMax<T>
	{
		public IntervalMinMax(T minimum, T maximum)
		{
			Minimum = minimum;
			Maximum = maximum;
		}

		public readonly T Minimum;
		public readonly T Maximum;
	}

	internal static class IntervalMinMax
	{
		private static readonly Dictionary<Type, object> Dictionary = new Dictionary<Type, object> 
		{
			{ typeof(byte), new IntervalMinMax<byte>(byte.MinValue, byte.MaxValue) },
			{ typeof(sbyte), new IntervalMinMax<sbyte>(sbyte.MinValue, sbyte.MaxValue) },
			{ typeof(char), new IntervalMinMax<char>(char.MinValue, char.MaxValue) },
			{ typeof(short), new IntervalMinMax<short>(short.MinValue, short.MaxValue) },
			{ typeof(ushort), new IntervalMinMax<ushort>(ushort.MinValue, ushort.MaxValue) },
			{ typeof(int), new IntervalMinMax<int>(int.MinValue, int.MaxValue) },
			{ typeof(uint), new IntervalMinMax<uint>(uint.MinValue, uint.MaxValue) },
			{ typeof(long), new IntervalMinMax<long>(long.MinValue, long.MaxValue) },
			{ typeof(ulong), new IntervalMinMax<ulong>(ulong.MinValue, ulong.MaxValue) },
			{ typeof(float), new IntervalMinMax<float>(float.MinValue, float.MaxValue) },
			{ typeof(double), new IntervalMinMax<double>(double.MinValue, double.MaxValue) },
		};

		public static IntervalMinMax<T> Get<T>()
		{
			return (IntervalMinMax<T>)IDictionaryExtensions.GetValueOrDefault(Dictionary, typeof(T), new IntervalMinMax<T>(default(T), default(T)) as object);
		}
	}

	internal static partial class Interval
	{
		public static Interval<byte> Union(Interval<byte> first, Interval<byte> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<byte> Intersect(Interval<byte> first, Interval<byte> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<byte> Complement(Interval<byte> first, Interval<byte> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<byte> Create(byte minimum, byte maximum)
		{
			return new Interval<byte>(minimum, maximum);
		}

		internal static Interval<byte> CreateMaximumUnbounded(byte minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<byte>(minimum, minimumPoint, byte.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<byte> CreateMinimumUnbounded(byte maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<byte>(byte.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<byte> Coerce(this Interval<byte> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? byte.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? byte.MaxValue : interval.Maximum;

			return new Interval<byte>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

		public static Interval<sbyte> Union(Interval<sbyte> first, Interval<sbyte> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<sbyte> Intersect(Interval<sbyte> first, Interval<sbyte> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<sbyte> Complement(Interval<sbyte> first, Interval<sbyte> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<sbyte> Create(sbyte minimum, sbyte maximum)
		{
			return new Interval<sbyte>(minimum, maximum);
		}

		internal static Interval<sbyte> CreateMaximumUnbounded(sbyte minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<sbyte>(minimum, minimumPoint, sbyte.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<sbyte> CreateMinimumUnbounded(sbyte maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<sbyte>(sbyte.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<sbyte> Coerce(this Interval<sbyte> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? sbyte.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? sbyte.MaxValue : interval.Maximum;

			return new Interval<sbyte>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

		public static Interval<char> Union(Interval<char> first, Interval<char> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<char> Intersect(Interval<char> first, Interval<char> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<char> Complement(Interval<char> first, Interval<char> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<char> Create(char minimum, char maximum)
		{
			return new Interval<char>(minimum, maximum);
		}

		internal static Interval<char> CreateMaximumUnbounded(char minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<char>(minimum, minimumPoint, char.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<char> CreateMinimumUnbounded(char maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<char>(char.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<char> Coerce(this Interval<char> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? char.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? char.MaxValue : interval.Maximum;

			return new Interval<char>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

		public static Interval<short> Union(Interval<short> first, Interval<short> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<short> Intersect(Interval<short> first, Interval<short> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<short> Complement(Interval<short> first, Interval<short> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<short> Create(short minimum, short maximum)
		{
			return new Interval<short>(minimum, maximum);
		}

		internal static Interval<short> CreateMaximumUnbounded(short minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<short>(minimum, minimumPoint, short.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<short> CreateMinimumUnbounded(short maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<short>(short.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<short> Coerce(this Interval<short> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? short.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? short.MaxValue : interval.Maximum;

			return new Interval<short>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

		public static Interval<ushort> Union(Interval<ushort> first, Interval<ushort> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<ushort> Intersect(Interval<ushort> first, Interval<ushort> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<ushort> Complement(Interval<ushort> first, Interval<ushort> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<ushort> Create(ushort minimum, ushort maximum)
		{
			return new Interval<ushort>(minimum, maximum);
		}

		internal static Interval<ushort> CreateMaximumUnbounded(ushort minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<ushort>(minimum, minimumPoint, ushort.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<ushort> CreateMinimumUnbounded(ushort maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<ushort>(ushort.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<ushort> Coerce(this Interval<ushort> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? ushort.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? ushort.MaxValue : interval.Maximum;

			return new Interval<ushort>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

		public static Interval<int> Union(Interval<int> first, Interval<int> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<int> Intersect(Interval<int> first, Interval<int> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<int> Complement(Interval<int> first, Interval<int> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<int> Create(int minimum, int maximum)
		{
			return new Interval<int>(minimum, maximum);
		}

		internal static Interval<int> CreateMaximumUnbounded(int minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<int>(minimum, minimumPoint, int.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<int> CreateMinimumUnbounded(int maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<int>(int.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<int> Coerce(this Interval<int> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? int.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? int.MaxValue : interval.Maximum;

			return new Interval<int>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

		public static Interval<uint> Union(Interval<uint> first, Interval<uint> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<uint> Intersect(Interval<uint> first, Interval<uint> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<uint> Complement(Interval<uint> first, Interval<uint> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<uint> Create(uint minimum, uint maximum)
		{
			return new Interval<uint>(minimum, maximum);
		}

		internal static Interval<uint> CreateMaximumUnbounded(uint minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<uint>(minimum, minimumPoint, uint.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<uint> CreateMinimumUnbounded(uint maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<uint>(uint.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<uint> Coerce(this Interval<uint> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? uint.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? uint.MaxValue : interval.Maximum;

			return new Interval<uint>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

		public static Interval<long> Union(Interval<long> first, Interval<long> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<long> Intersect(Interval<long> first, Interval<long> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<long> Complement(Interval<long> first, Interval<long> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<long> Create(long minimum, long maximum)
		{
			return new Interval<long>(minimum, maximum);
		}

		internal static Interval<long> CreateMaximumUnbounded(long minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<long>(minimum, minimumPoint, long.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<long> CreateMinimumUnbounded(long maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<long>(long.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<long> Coerce(this Interval<long> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? long.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? long.MaxValue : interval.Maximum;

			return new Interval<long>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

		public static Interval<ulong> Union(Interval<ulong> first, Interval<ulong> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<ulong> Intersect(Interval<ulong> first, Interval<ulong> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<ulong> Complement(Interval<ulong> first, Interval<ulong> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<ulong> Create(ulong minimum, ulong maximum)
		{
			return new Interval<ulong>(minimum, maximum);
		}

		internal static Interval<ulong> CreateMaximumUnbounded(ulong minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<ulong>(minimum, minimumPoint, ulong.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<ulong> CreateMinimumUnbounded(ulong maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<ulong>(ulong.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<ulong> Coerce(this Interval<ulong> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? ulong.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? ulong.MaxValue : interval.Maximum;

			return new Interval<ulong>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

		public static Interval<float> Union(Interval<float> first, Interval<float> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<float> Intersect(Interval<float> first, Interval<float> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<float> Complement(Interval<float> first, Interval<float> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<float> Create(float minimum, float maximum)
		{
			return new Interval<float>(minimum, maximum);
		}

		internal static Interval<float> CreateMaximumUnbounded(float minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<float>(minimum, minimumPoint, float.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<float> CreateMinimumUnbounded(float maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<float>(float.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<float> Coerce(this Interval<float> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? float.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? float.MaxValue : interval.Maximum;

			return new Interval<float>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

		public static Interval<double> Union(Interval<double> first, Interval<double> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<double> Intersect(Interval<double> first, Interval<double> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<double> Complement(Interval<double> first, Interval<double> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<double> Create(double minimum, double maximum)
		{
			return new Interval<double>(minimum, maximum);
		}

		internal static Interval<double> CreateMaximumUnbounded(double minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<double>(minimum, minimumPoint, double.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<double> CreateMinimumUnbounded(double maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<double>(double.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<double> Coerce(this Interval<double> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? double.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? double.MaxValue : interval.Maximum;

			return new Interval<double>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}


		public static Interval<byte> OpenMinimum(this Interval<byte> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<byte>((byte)(interval.Minimum + 1), IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);

			return new Interval<byte>(interval.Minimum, IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<byte> OpenMaximum(this Interval<byte> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<byte>(interval.Minimum, interval.MinimumPoint, (byte)(interval.Maximum + 1), IntervalEndPoint.Open);

			return new Interval<byte>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Open);
		}

		public static Interval<byte> CloseMaximum(this Interval<byte> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<byte>(interval.Minimum, interval.MinimumPoint, (byte)(interval.Maximum - 1), IntervalEndPoint.Closed);

			return new Interval<byte>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Closed);
		}

		public static Interval<byte> CloseMinimum(this Interval<byte> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<byte>((byte)(interval.Minimum - 1), IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);

			return new Interval<byte>(interval.Minimum, IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<byte> Normalize(this Interval<byte> interval, IntervalEndPoint minimumPoint, IntervalEndPoint maximumPoint)
		{
			var normalizedInterval = interval;

			if (normalizedInterval.MinimumPoint != minimumPoint)
			{
				if (normalizedInterval.MinimumPoint == IntervalEndPoint.Unbounded || minimumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMinimumUnbounded(normalizedInterval.Maximum, normalizedInterval.MaximumPoint);
				else if (normalizedInterval.MinimumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMinimum(true);
				else
					normalizedInterval = normalizedInterval.OpenMinimum(true);
			}

			if (normalizedInterval.MaximumPoint != maximumPoint)
			{
				if (normalizedInterval.MaximumPoint == IntervalEndPoint.Unbounded || maximumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMaximumUnbounded(normalizedInterval.Minimum, normalizedInterval.MinimumPoint);
				else if (normalizedInterval.MaximumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMaximum(true);
				else
					normalizedInterval = normalizedInterval.OpenMaximum(true);
			}

			return normalizedInterval;
		}
		public static Interval<sbyte> OpenMinimum(this Interval<sbyte> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<sbyte>((sbyte)(interval.Minimum + 1), IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);

			return new Interval<sbyte>(interval.Minimum, IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<sbyte> OpenMaximum(this Interval<sbyte> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<sbyte>(interval.Minimum, interval.MinimumPoint, (sbyte)(interval.Maximum + 1), IntervalEndPoint.Open);

			return new Interval<sbyte>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Open);
		}

		public static Interval<sbyte> CloseMaximum(this Interval<sbyte> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<sbyte>(interval.Minimum, interval.MinimumPoint, (sbyte)(interval.Maximum - 1), IntervalEndPoint.Closed);

			return new Interval<sbyte>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Closed);
		}

		public static Interval<sbyte> CloseMinimum(this Interval<sbyte> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<sbyte>((sbyte)(interval.Minimum - 1), IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);

			return new Interval<sbyte>(interval.Minimum, IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<sbyte> Normalize(this Interval<sbyte> interval, IntervalEndPoint minimumPoint, IntervalEndPoint maximumPoint)
		{
			var normalizedInterval = interval;

			if (normalizedInterval.MinimumPoint != minimumPoint)
			{
				if (normalizedInterval.MinimumPoint == IntervalEndPoint.Unbounded || minimumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMinimumUnbounded(normalizedInterval.Maximum, normalizedInterval.MaximumPoint);
				else if (normalizedInterval.MinimumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMinimum(true);
				else
					normalizedInterval = normalizedInterval.OpenMinimum(true);
			}

			if (normalizedInterval.MaximumPoint != maximumPoint)
			{
				if (normalizedInterval.MaximumPoint == IntervalEndPoint.Unbounded || maximumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMaximumUnbounded(normalizedInterval.Minimum, normalizedInterval.MinimumPoint);
				else if (normalizedInterval.MaximumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMaximum(true);
				else
					normalizedInterval = normalizedInterval.OpenMaximum(true);
			}

			return normalizedInterval;
		}
		public static Interval<char> OpenMinimum(this Interval<char> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<char>((char)(interval.Minimum + 1), IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);

			return new Interval<char>(interval.Minimum, IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<char> OpenMaximum(this Interval<char> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<char>(interval.Minimum, interval.MinimumPoint, (char)(interval.Maximum + 1), IntervalEndPoint.Open);

			return new Interval<char>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Open);
		}

		public static Interval<char> CloseMaximum(this Interval<char> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<char>(interval.Minimum, interval.MinimumPoint, (char)(interval.Maximum - 1), IntervalEndPoint.Closed);

			return new Interval<char>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Closed);
		}

		public static Interval<char> CloseMinimum(this Interval<char> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<char>((char)(interval.Minimum - 1), IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);

			return new Interval<char>(interval.Minimum, IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<char> Normalize(this Interval<char> interval, IntervalEndPoint minimumPoint, IntervalEndPoint maximumPoint)
		{
			var normalizedInterval = interval;

			if (normalizedInterval.MinimumPoint != minimumPoint)
			{
				if (normalizedInterval.MinimumPoint == IntervalEndPoint.Unbounded || minimumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMinimumUnbounded(normalizedInterval.Maximum, normalizedInterval.MaximumPoint);
				else if (normalizedInterval.MinimumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMinimum(true);
				else
					normalizedInterval = normalizedInterval.OpenMinimum(true);
			}

			if (normalizedInterval.MaximumPoint != maximumPoint)
			{
				if (normalizedInterval.MaximumPoint == IntervalEndPoint.Unbounded || maximumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMaximumUnbounded(normalizedInterval.Minimum, normalizedInterval.MinimumPoint);
				else if (normalizedInterval.MaximumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMaximum(true);
				else
					normalizedInterval = normalizedInterval.OpenMaximum(true);
			}

			return normalizedInterval;
		}
		public static Interval<short> OpenMinimum(this Interval<short> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<short>((short)(interval.Minimum + 1), IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);

			return new Interval<short>(interval.Minimum, IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<short> OpenMaximum(this Interval<short> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<short>(interval.Minimum, interval.MinimumPoint, (short)(interval.Maximum + 1), IntervalEndPoint.Open);

			return new Interval<short>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Open);
		}

		public static Interval<short> CloseMaximum(this Interval<short> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<short>(interval.Minimum, interval.MinimumPoint, (short)(interval.Maximum - 1), IntervalEndPoint.Closed);

			return new Interval<short>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Closed);
		}

		public static Interval<short> CloseMinimum(this Interval<short> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<short>((short)(interval.Minimum - 1), IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);

			return new Interval<short>(interval.Minimum, IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<short> Normalize(this Interval<short> interval, IntervalEndPoint minimumPoint, IntervalEndPoint maximumPoint)
		{
			var normalizedInterval = interval;

			if (normalizedInterval.MinimumPoint != minimumPoint)
			{
				if (normalizedInterval.MinimumPoint == IntervalEndPoint.Unbounded || minimumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMinimumUnbounded(normalizedInterval.Maximum, normalizedInterval.MaximumPoint);
				else if (normalizedInterval.MinimumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMinimum(true);
				else
					normalizedInterval = normalizedInterval.OpenMinimum(true);
			}

			if (normalizedInterval.MaximumPoint != maximumPoint)
			{
				if (normalizedInterval.MaximumPoint == IntervalEndPoint.Unbounded || maximumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMaximumUnbounded(normalizedInterval.Minimum, normalizedInterval.MinimumPoint);
				else if (normalizedInterval.MaximumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMaximum(true);
				else
					normalizedInterval = normalizedInterval.OpenMaximum(true);
			}

			return normalizedInterval;
		}
		public static Interval<ushort> OpenMinimum(this Interval<ushort> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<ushort>((ushort)(interval.Minimum + 1), IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);

			return new Interval<ushort>(interval.Minimum, IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<ushort> OpenMaximum(this Interval<ushort> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<ushort>(interval.Minimum, interval.MinimumPoint, (ushort)(interval.Maximum + 1), IntervalEndPoint.Open);

			return new Interval<ushort>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Open);
		}

		public static Interval<ushort> CloseMaximum(this Interval<ushort> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<ushort>(interval.Minimum, interval.MinimumPoint, (ushort)(interval.Maximum - 1), IntervalEndPoint.Closed);

			return new Interval<ushort>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Closed);
		}

		public static Interval<ushort> CloseMinimum(this Interval<ushort> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<ushort>((ushort)(interval.Minimum - 1), IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);

			return new Interval<ushort>(interval.Minimum, IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<ushort> Normalize(this Interval<ushort> interval, IntervalEndPoint minimumPoint, IntervalEndPoint maximumPoint)
		{
			var normalizedInterval = interval;

			if (normalizedInterval.MinimumPoint != minimumPoint)
			{
				if (normalizedInterval.MinimumPoint == IntervalEndPoint.Unbounded || minimumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMinimumUnbounded(normalizedInterval.Maximum, normalizedInterval.MaximumPoint);
				else if (normalizedInterval.MinimumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMinimum(true);
				else
					normalizedInterval = normalizedInterval.OpenMinimum(true);
			}

			if (normalizedInterval.MaximumPoint != maximumPoint)
			{
				if (normalizedInterval.MaximumPoint == IntervalEndPoint.Unbounded || maximumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMaximumUnbounded(normalizedInterval.Minimum, normalizedInterval.MinimumPoint);
				else if (normalizedInterval.MaximumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMaximum(true);
				else
					normalizedInterval = normalizedInterval.OpenMaximum(true);
			}

			return normalizedInterval;
		}
		public static Interval<int> OpenMinimum(this Interval<int> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<int>((int)(interval.Minimum + 1), IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);

			return new Interval<int>(interval.Minimum, IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<int> OpenMaximum(this Interval<int> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<int>(interval.Minimum, interval.MinimumPoint, (int)(interval.Maximum + 1), IntervalEndPoint.Open);

			return new Interval<int>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Open);
		}

		public static Interval<int> CloseMaximum(this Interval<int> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<int>(interval.Minimum, interval.MinimumPoint, (int)(interval.Maximum - 1), IntervalEndPoint.Closed);

			return new Interval<int>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Closed);
		}

		public static Interval<int> CloseMinimum(this Interval<int> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<int>((int)(interval.Minimum - 1), IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);

			return new Interval<int>(interval.Minimum, IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<int> Normalize(this Interval<int> interval, IntervalEndPoint minimumPoint, IntervalEndPoint maximumPoint)
		{
			var normalizedInterval = interval;

			if (normalizedInterval.MinimumPoint != minimumPoint)
			{
				if (normalizedInterval.MinimumPoint == IntervalEndPoint.Unbounded || minimumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMinimumUnbounded(normalizedInterval.Maximum, normalizedInterval.MaximumPoint);
				else if (normalizedInterval.MinimumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMinimum(true);
				else
					normalizedInterval = normalizedInterval.OpenMinimum(true);
			}

			if (normalizedInterval.MaximumPoint != maximumPoint)
			{
				if (normalizedInterval.MaximumPoint == IntervalEndPoint.Unbounded || maximumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMaximumUnbounded(normalizedInterval.Minimum, normalizedInterval.MinimumPoint);
				else if (normalizedInterval.MaximumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMaximum(true);
				else
					normalizedInterval = normalizedInterval.OpenMaximum(true);
			}

			return normalizedInterval;
		}
		public static Interval<uint> OpenMinimum(this Interval<uint> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<uint>((uint)(interval.Minimum + 1), IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);

			return new Interval<uint>(interval.Minimum, IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<uint> OpenMaximum(this Interval<uint> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<uint>(interval.Minimum, interval.MinimumPoint, (uint)(interval.Maximum + 1), IntervalEndPoint.Open);

			return new Interval<uint>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Open);
		}

		public static Interval<uint> CloseMaximum(this Interval<uint> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<uint>(interval.Minimum, interval.MinimumPoint, (uint)(interval.Maximum - 1), IntervalEndPoint.Closed);

			return new Interval<uint>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Closed);
		}

		public static Interval<uint> CloseMinimum(this Interval<uint> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<uint>((uint)(interval.Minimum - 1), IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);

			return new Interval<uint>(interval.Minimum, IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<uint> Normalize(this Interval<uint> interval, IntervalEndPoint minimumPoint, IntervalEndPoint maximumPoint)
		{
			var normalizedInterval = interval;

			if (normalizedInterval.MinimumPoint != minimumPoint)
			{
				if (normalizedInterval.MinimumPoint == IntervalEndPoint.Unbounded || minimumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMinimumUnbounded(normalizedInterval.Maximum, normalizedInterval.MaximumPoint);
				else if (normalizedInterval.MinimumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMinimum(true);
				else
					normalizedInterval = normalizedInterval.OpenMinimum(true);
			}

			if (normalizedInterval.MaximumPoint != maximumPoint)
			{
				if (normalizedInterval.MaximumPoint == IntervalEndPoint.Unbounded || maximumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMaximumUnbounded(normalizedInterval.Minimum, normalizedInterval.MinimumPoint);
				else if (normalizedInterval.MaximumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMaximum(true);
				else
					normalizedInterval = normalizedInterval.OpenMaximum(true);
			}

			return normalizedInterval;
		}
		public static Interval<long> OpenMinimum(this Interval<long> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<long>((long)(interval.Minimum + 1), IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);

			return new Interval<long>(interval.Minimum, IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<long> OpenMaximum(this Interval<long> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<long>(interval.Minimum, interval.MinimumPoint, (long)(interval.Maximum + 1), IntervalEndPoint.Open);

			return new Interval<long>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Open);
		}

		public static Interval<long> CloseMaximum(this Interval<long> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<long>(interval.Minimum, interval.MinimumPoint, (long)(interval.Maximum - 1), IntervalEndPoint.Closed);

			return new Interval<long>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Closed);
		}

		public static Interval<long> CloseMinimum(this Interval<long> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<long>((long)(interval.Minimum - 1), IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);

			return new Interval<long>(interval.Minimum, IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<long> Normalize(this Interval<long> interval, IntervalEndPoint minimumPoint, IntervalEndPoint maximumPoint)
		{
			var normalizedInterval = interval;

			if (normalizedInterval.MinimumPoint != minimumPoint)
			{
				if (normalizedInterval.MinimumPoint == IntervalEndPoint.Unbounded || minimumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMinimumUnbounded(normalizedInterval.Maximum, normalizedInterval.MaximumPoint);
				else if (normalizedInterval.MinimumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMinimum(true);
				else
					normalizedInterval = normalizedInterval.OpenMinimum(true);
			}

			if (normalizedInterval.MaximumPoint != maximumPoint)
			{
				if (normalizedInterval.MaximumPoint == IntervalEndPoint.Unbounded || maximumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMaximumUnbounded(normalizedInterval.Minimum, normalizedInterval.MinimumPoint);
				else if (normalizedInterval.MaximumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMaximum(true);
				else
					normalizedInterval = normalizedInterval.OpenMaximum(true);
			}

			return normalizedInterval;
		}
		public static Interval<ulong> OpenMinimum(this Interval<ulong> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<ulong>((ulong)(interval.Minimum + 1), IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);

			return new Interval<ulong>(interval.Minimum, IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<ulong> OpenMaximum(this Interval<ulong> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<ulong>(interval.Minimum, interval.MinimumPoint, (ulong)(interval.Maximum + 1), IntervalEndPoint.Open);

			return new Interval<ulong>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Open);
		}

		public static Interval<ulong> CloseMaximum(this Interval<ulong> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<ulong>(interval.Minimum, interval.MinimumPoint, (ulong)(interval.Maximum - 1), IntervalEndPoint.Closed);

			return new Interval<ulong>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Closed);
		}

		public static Interval<ulong> CloseMinimum(this Interval<ulong> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<ulong>((ulong)(interval.Minimum - 1), IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);

			return new Interval<ulong>(interval.Minimum, IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<ulong> Normalize(this Interval<ulong> interval, IntervalEndPoint minimumPoint, IntervalEndPoint maximumPoint)
		{
			var normalizedInterval = interval;

			if (normalizedInterval.MinimumPoint != minimumPoint)
			{
				if (normalizedInterval.MinimumPoint == IntervalEndPoint.Unbounded || minimumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMinimumUnbounded(normalizedInterval.Maximum, normalizedInterval.MaximumPoint);
				else if (normalizedInterval.MinimumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMinimum(true);
				else
					normalizedInterval = normalizedInterval.OpenMinimum(true);
			}

			if (normalizedInterval.MaximumPoint != maximumPoint)
			{
				if (normalizedInterval.MaximumPoint == IntervalEndPoint.Unbounded || maximumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMaximumUnbounded(normalizedInterval.Minimum, normalizedInterval.MinimumPoint);
				else if (normalizedInterval.MaximumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMaximum(true);
				else
					normalizedInterval = normalizedInterval.OpenMaximum(true);
			}

			return normalizedInterval;
		}
	}
}
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

// <copyright file="Interval.cs" author="Dmitry Kravchenin" email="d.kravchenin@zaaml.com">
//   Copyright (c) Zaaml. All rights reserved.
// </copyright>

// *************************************************************
//
// AutoGenerated
//
// *************************************************************

// ReSharper disable All

using System;
using System.Collections.Generic;
using Zaaml.Core.Extensions;

<#
var typeNames = new List<string>{ "byte", "sbyte", "char", "short", "ushort", "int", "uint", "long", "ulong", "float", "double" };
var integralTypeNames = new List<string>{ "byte", "sbyte", "char", "short", "ushort", "int", "uint", "long", "ulong" };
#>

namespace Zaaml.Core
{
	internal struct IntervalMinMax<T>
	{
		public IntervalMinMax(T minimum, T maximum)
		{
			Minimum = minimum;
			Maximum = maximum;
		}

		public readonly T Minimum;
		public readonly T Maximum;
	}

	internal static class IntervalMinMax
	{
		private static readonly Dictionary<Type, object> Dictionary = new Dictionary<Type, object> 
		{
<#
		foreach (var t in typeNames)
		{
#>
			{ typeof(<#= t #>), new IntervalMinMax<<#= t #>>(<#= t #>.MinValue, <#= t #>.MaxValue) },
<#
}
#>
		};

		public static IntervalMinMax<T> Get<T>()
		{
			return (IntervalMinMax<T>)IDictionaryExtensions.GetValueOrDefault(Dictionary, typeof(T), new IntervalMinMax<T>(default(T), default(T)) as object);
		}
	}

	internal static partial class Interval
	{
<#
foreach (var t in typeNames)
{
#>
		public static Interval<<#= t #>> Union(Interval<<#= t#>> first, Interval<<#= t#>> second)
		{
			return UnionImpl(first, second).Coerce();
		}

		public static Interval<<#= t #>> Intersect(Interval<<#= t #>> first, Interval<<#= t #>> second)
		{
			return IntersectImpl(first, second).Coerce();
		}

		//public static Interval<<#= t #>> Complement(Interval<<#= t #>> first, Interval<<#= t #>> second)
		//{
		//	return ComplementImpl(first, second).Coerce();
		//}

		public static Interval<<#= t #>> Create(<#= t #> minimum, <#= t #> maximum)
		{
			return new Interval<<#= t #>>(minimum, maximum);
		}

		internal static Interval<<#= t #>> CreateMaximumUnbounded(<#= t #> minimum, IntervalEndPoint minimumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<<#= t #>>(minimum, minimumPoint, <#= t #>.MaxValue, IntervalEndPoint.Unbounded);
		}

		internal static Interval<<#= t #>> CreateMinimumUnbounded(<#= t #> maximum, IntervalEndPoint maximumPoint = IntervalEndPoint.Closed)
		{
			return new Interval<<#= t #>>(<#= t #>.MinValue, IntervalEndPoint.Unbounded, maximum, maximumPoint);
		}

		private static Interval<<#= t #>> Coerce(this Interval<<#= t #>> interval)
		{
			var minimum = interval.MinimumPoint == IntervalEndPoint.Unbounded ? <#= t #>.MinValue : interval.Minimum;
			var maximum = interval.MaximumPoint == IntervalEndPoint.Unbounded ? <#= t #>.MaxValue : interval.Maximum;

			return new Interval<<#= t #>>(minimum, interval.MinimumPoint, maximum, interval.MaximumPoint);
		}

<#
}
#>

<#
foreach (var t in integralTypeNames)
{
#>
		public static Interval<<#= t #>> OpenMinimum(this Interval<<#= t #>> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<<#= t #>>((<#= t #>)(interval.Minimum + 1), IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);

			return new Interval<<#= t #>>(interval.Minimum, IntervalEndPoint.Open, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<<#= t #>> OpenMaximum(this Interval<<#= t #>> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Open)
				return interval;

			if (preserveInterval)
				return new Interval<<#= t #>>(interval.Minimum, interval.MinimumPoint, (<#= t #>)(interval.Maximum + 1), IntervalEndPoint.Open);

			return new Interval<<#= t #>>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Open);
		}

		public static Interval<<#= t #>> CloseMaximum(this Interval<<#= t #>> interval, bool preserveInterval)
		{
			if (interval.MaximumPoint == IntervalEndPoint.Unbounded || interval.MaximumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<<#= t #>>(interval.Minimum, interval.MinimumPoint, (<#= t #>)(interval.Maximum - 1), IntervalEndPoint.Closed);

			return new Interval<<#= t #>>(interval.Minimum, interval.MinimumPoint, interval.Maximum, IntervalEndPoint.Closed);
		}

		public static Interval<<#= t #>> CloseMinimum(this Interval<<#= t #>> interval, bool preserveInterval)
		{
			if (interval.MinimumPoint == IntervalEndPoint.Unbounded || interval.MinimumPoint == IntervalEndPoint.Closed)
				return interval;

			if (preserveInterval)
				return new Interval<<#= t #>>((<#= t #>)(interval.Minimum - 1), IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);

			return new Interval<<#= t #>>(interval.Minimum, IntervalEndPoint.Closed, interval.Maximum, interval.MaximumPoint);
		}

		public static Interval<<#= t #>> Normalize(this Interval<<#= t #>> interval, IntervalEndPoint minimumPoint, IntervalEndPoint maximumPoint)
		{
			var normalizedInterval = interval;

			if (normalizedInterval.MinimumPoint != minimumPoint)
			{
				if (normalizedInterval.MinimumPoint == IntervalEndPoint.Unbounded || minimumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMinimumUnbounded(normalizedInterval.Maximum, normalizedInterval.MaximumPoint);
				else if (normalizedInterval.MinimumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMinimum(true);
				else
					normalizedInterval = normalizedInterval.OpenMinimum(true);
			}

			if (normalizedInterval.MaximumPoint != maximumPoint)
			{
				if (normalizedInterval.MaximumPoint == IntervalEndPoint.Unbounded || maximumPoint == IntervalEndPoint.Unbounded)
					normalizedInterval = CreateMaximumUnbounded(normalizedInterval.Minimum, normalizedInterval.MinimumPoint);
				else if (normalizedInterval.MaximumPoint == IntervalEndPoint.Open)
					normalizedInterval = normalizedInterval.CloseMaximum(true);
				else
					normalizedInterval = normalizedInterval.OpenMaximum(true);
			}

			return normalizedInterval;
		}
<#
}
#>
	}
}
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

// <copyright file="GrammarBuilders.cs" author="Dmitry Kravchenin" email="d.kravchenin@zaaml.com">
//   Copyright (c) Zaaml. All rights reserved.
// </copyright>

// *************************************************************
//
// AutoGenerated
//
// *************************************************************

// ReSharper disable All

<#
var lexerEntries = new List<string>
{ 
	"CharEntry",
	"QuantifierEntry", 
	"RangeEntry", 
	"SetEntry", 
	"TokenFragment", 
	"TokenFragmentEntry",
	"LexerAction",
	"LexerPredicate"
};

var parserEntries = new List<string>
{ 
	"ParserAction",
	"ParserFragment",
	"ParserPredicate",
	"ParserQuantifierEntry",
	"ParserRuleEntry",
	"ParserTokenRuleEntry",
	"ParserRule",
	"SubParserEntry",
	"SubLexerEntry",
	"TokenRuleSet"
};

#>
namespace Zaaml.Text
{
	internal partial class Grammar<TToken>
	{
<#
		// Lexer operators
		foreach (var t in lexerEntries)
		{
#>
			partial class <#= t #>
			{
				public static PatternCollectionBuilder operator |(<#= t #> op1, PatternCollectionBuilder op2)
				{
					return new PatternCollectionBuilder(new TokenEntry[] { op1 }) | op2;
				}

				public static PatternCollectionBuilder operator |(PatternCollectionBuilder op1, <#= t #> op2)
				{
					return op1 | new PatternCollectionBuilder(new TokenEntry[] { op2 });
				}

				public static PatternBuilder operator +(<#= t #> op1, PatternCollectionBuilder op2)
				{
					return new PatternBuilder(op1) + op2.AsFragment();
				}

				public static PatternBuilder operator +(PatternCollectionBuilder op1, <#= t #> op2)
				{
					return new PatternBuilder(op1.AsFragment()) + op2;
				}

				public static PatternBuilder operator +(PatternBuilder op1, <#= t #> op2)
				{
					return op1 + new PatternBuilder(op2);
				}

				public static PatternBuilder operator +(<#= t #> op1, PatternBuilder op2)
				{
					return new PatternBuilder(op1) + op2;
				}

				public static PatternCollectionBuilder operator |(PatternBuilder op1, <#= t #> op2)
				{
					return new PatternCollectionBuilder() | op1 | new PatternBuilder(op2);
				}

				public static PatternCollectionBuilder operator |(<#= t #> op1, PatternBuilder op2)
				{
					return new PatternCollectionBuilder() | new PatternBuilder(op1) | op2;
				}

<#
			foreach (var tOp in lexerEntries)
			{
#>
				public static PatternBuilder operator +(<#= t #> op1, <#= tOp #> op2)
				{
					return new PatternBuilder(op1) + op2;
				}		
				
				public static PatternCollectionBuilder operator |(<#= t #> op1, <#= tOp #> op2)
				{
					return new PatternCollectionBuilder() | op1 | op2;
				}

<#
			}
#>

<#
		var extLexerEntries = new List<string>
		{ 
			"Lexer<TToken>.PredicateEntry",
			"Lexer<TToken>.ActionEntry"
		};


			foreach (var tOp in extLexerEntries)
			{
#>
				public static PatternBuilder operator +(<#= t #> op1, <#= tOp #> op2)
				{
					return new PatternBuilder(op1) + (TokenEntry)op2;
				}

				public static PatternBuilder operator +(<#= tOp #> op1, <#= t #> op2)
				{
					return new PatternBuilder((TokenEntry)op1) + op2;
				}	
				
				public static PatternCollectionBuilder operator |(<#= t #> op1, <#= tOp #> op2)
				{
					return new PatternCollectionBuilder() | op1 | (TokenEntry)op2;
				}				

				public static PatternCollectionBuilder operator |(<#= tOp #> op1, <#= t #> op2)
				{
					return new PatternCollectionBuilder() | (TokenEntry)op1 | op2;
				}

<#
			}
#>
			}

<#
		}

#>
			partial class TokenRule
			{
<#
		var extEntries = new List<string>
		{ 
			"Parser<TToken>.PredicateEntry",
			"Parser<TToken>.ActionEntry"
		};
		// Parser operators
		foreach (var t in parserEntries.Concat(extEntries))
		{
#>
				public static ParserProductionBuilder operator +(<#= t #> op1, TokenRule op2)
				{
					return new ParserProductionBuilder(op1) + new ParserProductionBuilder(op2);
				}

				public static ParserProductionBuilder operator +(TokenRule op1, <#= t #> op2)
				{
					return new ParserProductionBuilder(op1) + new ParserProductionBuilder(op2);
				}	

				public static ParserProductionCollectionBuilder operator |(<#= t #> op1, TokenRule op2)
				{
					return new ParserProductionCollectionBuilder() | op1 | op2;
				}

				public static ParserProductionCollectionBuilder operator |(TokenRule op1, <#= t #> op2)
				{
					return new ParserProductionCollectionBuilder() | op1 | op2;
				}	
<#
		}
#>
			}

<#
		// Parser operators
		foreach (var t in parserEntries)
		{
#>
			partial class <#= t #>
			{
				public static implicit operator ParserProduction(<#= t #> entry)
				{
					return new ParserProduction(new ParserEntry[] { entry });
				}

				public static ParserProductionBuilder operator +(<#= t #> op1, ParserProductionCollectionBuilder op2)
				{
					return new ParserProductionBuilder(op1) + op2.AsFragment();
				}

				public static ParserProductionBuilder operator +(ParserProductionCollectionBuilder op1, <#= t #> op2)
				{
					return op1.AsFragment() + new ParserProductionBuilder(op2);
				}

				public static ParserProductionBuilder operator +(<#= t #> op1, TokenInterProductionCollectionBuilder op2)
				{
					return new ParserProductionBuilder(op1) + new ParserProductionBuilder(op2.AsFragment().CreateParserEntry());
				}

				public static ParserProductionBuilder operator +(TokenInterProductionCollectionBuilder op1, <#= t #> op2)
				{
					return new ParserProductionBuilder(op1.AsFragment().CreateParserEntry()) + new ParserProductionBuilder(op2);
				}

				public static ParserProductionBuilder operator +(ParserProductionBuilder op1, <#= t #> op2)
				{
					return op1 + new ParserProductionBuilder(op2);
				}

				public static ParserProductionBuilder operator +(<#= t #> op1, ParserProductionBuilder op2)
				{
					return new ParserProductionBuilder(op1) + op2;
				}

				public static ParserProductionBuilder operator +(<#= t #> op1, TokenInterProductionBuilder op2)
				{
					return new ParserProductionBuilder(op1) + op2.AsParserProductionBuilder();
				}
								
				public static ParserProductionBuilder operator +(TokenInterProductionBuilder op1, <#= t #> op2)
				{
					return op1.AsParserProductionBuilder() + new ParserProductionBuilder(op2);
				}

				public static ParserProductionBuilder operator +(<#= t #> op1, TokenInterEntry op2)
				{
					return new ParserProductionBuilder(op1) + new ParserProductionBuilder(op2.CreateParserEntry());
				}
								
				public static ParserProductionBuilder operator +(TokenInterEntry op1, <#= t #> op2)
				{
					return new ParserProductionBuilder(op1.CreateParserEntry()) + new ParserProductionBuilder(op2);
				}

				public static ParserProductionCollectionBuilder operator |(<#= t #> op1, ParserProductionCollectionBuilder op2)
				{
					return new ParserProductionCollectionBuilder(new ParserProduction(new ParserEntry[] { op1 })) | op2;
				}

				public static ParserProductionCollectionBuilder operator |(ParserProductionCollectionBuilder op1, <#= t #> op2)
				{
					return op1 | new ParserProductionCollectionBuilder(new ParserProduction(new ParserEntry[] { op2 }));
				}

				public static ParserProductionCollectionBuilder operator |(<#= t #> op1, ParserProductionBuilder op2)
				{
					return new ParserProductionCollectionBuilder() | new ParserProductionBuilder(op1) | op2;
				}
				public static ParserProductionCollectionBuilder operator |(ParserProductionBuilder op1, <#= t #> op2)
				{
					return new ParserProductionCollectionBuilder() | op1 | new ParserProductionBuilder(op2);
				}

				public static ParserProductionCollectionBuilder operator |(<#= t #> op1, TokenInterProductionBuilder op2)
				{
					return new ParserProductionCollectionBuilder() | new ParserProductionBuilder(op1) | op2.AsParserProductionBuilder();
				}
								
				public static ParserProductionCollectionBuilder operator |(TokenInterProductionBuilder op1, <#= t #> op2)
				{
					return new ParserProductionCollectionBuilder() | op1.AsParserProductionBuilder() | new ParserProductionBuilder(op2);
				}

				public static ParserProductionCollectionBuilder operator |(<#= t #> op1, TokenInterProductionCollectionBuilder op2)
				{
					return new ParserProductionCollectionBuilder() | new ParserProductionBuilder(op1) | new ParserProductionBuilder(op2.AsFragment().CreateParserEntry());
				}
								
				public static ParserProductionCollectionBuilder operator |(TokenInterProductionCollectionBuilder op1, <#= t #> op2)
				{
					return new ParserProductionCollectionBuilder() | new ParserProductionBuilder(op1.AsFragment().CreateParserEntry()) | new ParserProductionBuilder(op2);
				}

<#
			foreach (var tOp in parserEntries)
			{
#>
				public static ParserProductionBuilder operator +(<#= t #> op1, <#= tOp #> op2)
				{
					return new ParserProductionBuilder(op1) + new ParserProductionBuilder(op2);
				}		
				
				public static ParserProductionCollectionBuilder operator |(<#= t #> op1, <#= tOp #> op2)
				{
					return new ParserProductionCollectionBuilder() | op1 | op2;
				}

<#
			}
#>
			}

<#
		}

#>
<#
		var parserProductionBuilderOpEntries = new List<string>
		{ 
			"TokenRule",
			"Parser<TToken>.PredicateEntry",
			"Parser<TToken>.ActionEntry"
		};

		// Parser operators
		foreach (var t in parserProductionBuilderOpEntries)
		{
#>
			partial struct ParserProductionBuilder
			{
				public static ParserProductionBuilder operator +(ParserProductionBuilder op1, <#= t #> op2)
				{
					return op1 + new ParserProductionBuilder(op2);
				}

				public static ParserProductionBuilder operator +(<#= t #> op1, ParserProductionBuilder op2)
				{
					return new ParserProductionBuilder(op1) + op2;
				}

				public static ParserProductionCollectionBuilder operator |(ParserProductionBuilder op1, <#= t #> op2)
				{
					return new ParserProductionCollectionBuilder() | op1 | new ParserProductionBuilder(op2);
				}

				public static ParserProductionCollectionBuilder operator |(<#= t #> op1, ParserProductionBuilder op2)
				{
					return new ParserProductionCollectionBuilder() | new ParserProductionBuilder(op1) | op2;
				}
			}

			partial struct ParserProductionCollectionBuilder
			{
				public static ParserProductionCollectionBuilder operator |(ParserProductionCollectionBuilder op1, <#= t #> op2)
				{
					return op1 | new ParserProductionCollectionBuilder(new ParserProduction(new ParserEntry[] { op2 }));
				}

				public static ParserProductionCollectionBuilder operator |(<#= t #> op1, ParserProductionCollectionBuilder op2)
				{
					return new ParserProductionCollectionBuilder(new ParserProduction(new ParserEntry[] { op1 })) | op2;
				}
			}
<#
		}
#>
<#
		var tokenInterProductionBuilderOpEntries = new List<string>
		{ 
			"Parser<TToken>.PredicateEntry",
			"Parser<TToken>.ActionEntry"
		};

		// Parser operators
		foreach (var t in tokenInterProductionBuilderOpEntries)
		{
#>
			partial struct TokenInterProductionBuilder
			{
				public static ParserProductionBuilder operator +(TokenInterProductionBuilder op1, <#= t #> op2)
				{
					return op1.AsParserProductionBuilder() + new ParserProductionBuilder(op2);
				}

				public static ParserProductionBuilder operator +(<#= t #> op1, TokenInterProductionBuilder op2)
				{
					return new ParserProductionBuilder(op1) + op2.AsParserProductionBuilder();
				}
			}
<#
		}
#>
	}
}
